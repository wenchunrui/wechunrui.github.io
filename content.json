[{"title":"图像处理","date":"2020-06-01T13:20:01.920Z","path":"2020/06/01/图像处理/","text":"图像处理 学前了解 在php中通过GD库处理图像函数的操作,都是先在内存中处理,错做完成以后再以文件流的方式,输出到浏览器或者保存在返屋企的磁盘中. 学前需求 开启GD库扩展 创建一个图像应该完成如下所示的几个基本步骤 创建图像:所有的绘图设计都需要在一个图像上完成，以后操作都基于这个图像。 绘制图像：图像创建完成以后，就可以通过这个图像资源，使用各种画像函数设置图像的颜色、填充画布、画点、线段、各种几何图形，以及向图像的添加文本等。 生成图像：完成整个图像的绘制之后，需要将图像以某种格式保存到服务器的文件中，或者将图像直接输出到浏览器上显示给用户。但在图像输出之前，一定要使用header()函数发送Content-type通知浏览器，这次发送的是图片不是文本 释放资源 创建图像 绘制图像 生成图像 header();函数注意点：在该函数之前不能输出任何内容 释放资源 图形验证码 水印 缩放与裁剪 验证码例子 123456789101112131415161718192021222324header('Content-type: image/jpeg');$width = 120;$height = 40;$element = array('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z');$string = '';for ($i=0;$i&lt;5;$i++)&#123; $string .= $element[rand(0,count($element)-1)];&#125;$img = imagecreatetruecolor($width,$height);//创建一个图片资源$colorBg = imagecolorallocate($img, rand(200,255), rand(200,255), rand(200,255));//调色$colorBorder = imagecolorallocate($img, rand(200,255), rand(200,255), rand(200,255));$colorString = imagecolorallocate($img, rand(10,100), rand(10,100), rand(10,100));imagefill($img, 0, 0, $colorBg);//背景颜色imagerectangle($img,0,0,$width-1,$height-1,$colorBorder);//画矩形,边框for ($i=0;$i&lt;200;$i++)&#123; imagesetpixel($img, rand(0,$width-1), rand(0,$height-1),imagecolorallocate($img, rand(100,200), rand(100,200), rand(100,200)));//画点&#125;for ($i=0;$i&lt;3;$i++)&#123; imageline($img,rand(0,$width/2),rand(0,$height),rand($width/2,0),rand($height/2,0),imagecolorallocate($img, rand(100,200), rand(100,200), rand(100,200)));//画线&#125;//imagestring($img,5,0,0,'abcd',$colorString);//添加文本内容imagettftext($img, 48, rand(-10,10),rand(12,20),rand(28,32),$colorString,'font/Self-Deception-2.ttf',$string);//添加文本内容,可以修改字体大小,更换字体imagejpeg($img);//输出给浏览器imagedestroy($img);//释放资源 添加文字水印例子 12345678910header('Content-type: image/jpeg');$img = imagecreatefromjpeg('images/timg.jpeg');//获取本地图片或线上图片,线上图片填写url$color = imagecolorallocate($img,255,255,255);//调色$width = imagesx($img);//获取图片资源的宽度$height = imagesy($img);//获取图片资源的高度$position = imagettfbbox(20,0,'font/hjt.ttf','锐');//获取字体的8个基点,分别为左下角 X 位置/左下角 Y 位置/右下角 X 位置/右下角 Y 位置/右上角 X 位置/右上角 Y 位置/左上角 X 位置/左上角 Y 位置以数组的方式返回$stringWidth = $position[2]-$position[0];//用右下角 X 位置-左下角 X 位置获取字符串的长度imagettftext($img,50,0,$width-1-$stringWidth-($width/30),$height-1-($height/30),$color,'font/hjt.ttf','锐');//添加文本水印imagejpeg($img);//发送给浏览器imagedestroy($img);//释放资源 imagecopy 123456789101112131415161718192021222324header('Content-type: image/jpeg');$img = imagecreatefromjpeg('images/timg.jpeg');//获取本地图片或线上图片,线上图片填写url$waterMark = imagecreatefrompng('images/xiao.png');$color = imagecolorallocate($img,255,255,255);//调色$width = imagesx($img);//获取图片资源的宽度$height = imagesy($img);//获取图片资源的高度$waterMarkWidth = imagesx($waterMark);//获取图片资源的宽度$waterMarkHeight = imagesy($waterMark);//获取图片资源的高度$position = imagettfbbox(20,0,'font/hjt.ttf','锐');//获取字体的8个基点,分别为左下角 X 位置/左下角 Y 位置/右下角 X 位置/右下角 Y 位置/右上角 X 位置/右上角 Y 位置/左上角 X 位置/左上角 Y 位置以数组的方式返回$stringWidth = $position[2]-$position[0];//用右下角 X 位置-左下角 X 位置获取字符串的长度/* * 参数说明: * $img:目标图像资源; * $waterMark:水印图片资源; * 100:所要拷贝到目标图像资源上面的坐标(x轴坐标); * 100:所要拷贝到目标图像资源上面的坐标(y轴坐标); * 0:从水印的图像资源的x坐标为0的位置开始拷贝; * 0:从水印的图像资源的y坐标为0的位置开始拷贝; * $waterMarkWidth:所要拷贝的水印图像的长度; * $waterMarkHeight:所要拷贝的水印图像的长度; * */imagecopy($img,$waterMark,100,100,0,0,$waterMarkWidth,$waterMarkHeight);imagejpeg($img);//发送给浏览器imagedestroy($img);//释放资源 imagecopymerge() 12345678910111213141516171819202122232425header('Content-type: image/jpeg');$img = imagecreatefromjpeg('images/timg.jpeg');//获取本地图片或线上图片,线上图片填写url$waterMark = imagecreatefrompng('images/xiao.png');$color = imagecolorallocate($img,255,255,255);//调色$width = imagesx($img);//获取图片资源的宽度$height = imagesy($img);//获取图片资源的高度$waterMarkWidth = imagesx($waterMark);//获取图片资源的宽度$waterMarkHeight = imagesy($waterMark);//获取图片资源的高度$position = imagettfbbox(20,0,'font/hjt.ttf','锐');//获取字体的8个基点,分别为左下角 X 位置/左下角 Y 位置/右下角 X 位置/右下角 Y 位置/右上角 X 位置/右上角 Y 位置/左上角 X 位置/左上角 Y 位置以数组的方式返回$stringWidth = $position[2]-$position[0];//用右下角 X 位置-左下角 X 位置获取字符串的长度/* * 参数说明: * $img:目标图像资源; * $waterMark:水印图片资源; * 100:所要拷贝到目标图像资源上面的坐标(x轴坐标); * 100:所要拷贝到目标图像资源上面的坐标(y轴坐标); * 0:从水印的图像资源的x坐标为0的位置开始拷贝; * 0:从水印的图像资源的y坐标为0的位置开始拷贝; * $waterMarkWidth:所要拷贝的水印图像的长度; * $waterMarkHeight:所要拷贝的水印图像的长度; * 0:水印图片透明度,数值越小越透明,100相当于未改变; * */imagecopymerge($img,$waterMark,100,100,0,0,$waterMarkWidth,$waterMarkHeight,50);imagejpeg($img);//发送给浏览器imagedestroy($img);//释放资源 imagecopyresampled 123456789101112131415161718192021222324header('Content-type: image/jpeg');$img = imagecreatefromjpeg('images/timg.jpeg');$width = 100;$imgWidth = imagesx($img);$imgHeight = imagesy($img);$height = $width/($imgWidth/$imgHeight);$ima1 = imagecreatetruecolor($width,$height);/* * imagecopyresampled()函数每个参数讲解 * dst_image.目标函数资源 * src_image.源图像资源(你要采样的那个图像资源) * dst_x. * dst_y.与上面的dst_x确定了一个坐标,把采样到得部分放到目标图像资源的什么位置 * src_x. * src_y.与上面的src_y确定了一个左边,你要采样的原图像资源的某个部分的起始坐标 * dst_w. * dst_y.与上面的dst_w确定了放到目标图像资源上面的尺寸 * src_w. * src_h.与上面的src_w确定了采样原图像资源的某个部分尺寸 * */imagecopyresampled($ima1,$img,0,0,0,0,$width,$height,$width,$height);imagejpeg($ima1);imagedestroy($ima1);","tags":[]},{"title":"vue初入坑","date":"2020-06-01T13:15:16.217Z","path":"2020/06/01/vue初入坑/","text":"简介1.jiavascript框架2.简化DOM操作3.响应式数据驱动 使用初始导入开发版本的vue.jsvue.js官网 el:挂载点1.vue实例的作用范围：vue会管理el选项命中的元素及内部的后代元素2.可以使用多种选择权，但是建议使用ID选择器3.可以设置于所有的双标签，但是不要设置于HTML和BODY 123456var app = new Vue(&#123; el: \"#id\", data: &#123; message: \"测试\" &#125;&#125;) data:数据对象1.vue中用到的数据定义在data中2.data中可以写复杂类型的数据3.渲染复杂类型数据时，遵守js的语法 123456789101112131415161718192021222324&lt;html&gt; &lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125; &lt;h2&gt;&#123;&#123; obj.name &#125;&#125; &#123;&#123; obj.age &#125;&#125;&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&#123;&#123; list[0] &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; list[1] &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; list[2] &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/html&gt;&lt;script&gt; var app = new Vue(&#123; el: \"app\", data: &#123; message: \"测试一下\", obj: &#123; name: \"rui\", age: \"18\" &#125;, list: [\"red\",\"blue\",\"pink\"] &#125; &#125;)&lt;/script&gt; 指令标签的学习1.v-text:1.1.相当于textContent,设置标签内容1.2.默认写法会替换全部内容，使用差值表达式可以替换指定内容1.3.内部支持表达式 12345678910111213141516&lt;html&gt; &lt;div id=\"app\"&gt; &lt;h2 v-text=\"message\"&gt;&lt;/h2&gt; &lt;h2 v-text=\"text+'!!'\"&gt;&lt;/h2&gt; &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/html&gt;&lt;script&gt; var app = new Vue(&#123; el: \"app\", data: &#123; message: \"测试一下\", text: \"测试第二下\" &#125; &#125;)&lt;/script&gt; 2.v-html:2.1.设置元素的innerHTML2.2.内容中有html结构会被解析为标签2.3.v-text指令无论内容是什么，只会解析为文本2.4.解析文本使用v-text，需要解析html结构使用v-html 1234567891011121314&lt;html&gt; &lt;div id=\"app\"&gt; &lt;p v-html=\"content\"&gt;&lt;/p&gt; &lt;p v-text=\"content\"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/html&gt;&lt;script&gt; var app = new Vue(&#123; el: \"app\", data: &#123; content: \"&lt;a href='www.baidu.com'&gt;百度一下&lt;/a&gt;\" &#125; &#125;)&lt;/script&gt; 3.v-on:3.1.为元素绑定事件3.2.事件名不需要写on3.3.指令可以简写为@3.4.绑定的方法定义在methods属性中3.5.方法内部通过this关键字可以访问定义在data中得数据 123456789101112131415161718192021222324&lt;html&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"v-on指令\" v-on:click=\"cs\"&gt; &lt;input typt=\"button\" value=\"简写\" @click=\"cs\"&gt; &lt;input type=\"button\" value=\"双击事件\" @dblclick=\"cs\"&gt; &lt;h2 @click=\"changeFn\"&gt;&#123;&#123; cs &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/html&gt;&lt;script&gt; var app = new Vue(&#123; el: \"app\", data: &#123; cs: \"测试数据\" &#125;, methods: &#123; cs:function()&#123; alert(\"测试一下\") &#125;, changeFn:()&#123; this.cs+=\"!!!\" &#125; &#125; &#125;)&lt;/script&gt; 4.v-show:4.1.根据元素的真假切换元素的现实状态4.2.原理是修改元素的display实现显示隐藏4.3.指令后面的内容最终都会解析为布尔值4.4.值为true元素显示，值为false元素隐藏4.5.数据改变之后，对应元素的显示状态会同步更新 5.v-if:5.1.根据元素的真假切换元素的现实状态5.2.本质是通过操纵dom元素来切换显示状态5.3.表达式的值为true，元素存在dom树中，为false，从dom树中移除5.4.频繁的切换v-show，反之使用v-if，前者消耗性能比较少 6.v-bind:6.1.为元素绑定属性6.2.完整写法是v-bind:属性名6.3.简写的话可以直接省略v-bind，只保留：属性名6.4.需要动态的增删class建议使用对象的方式 7.v-for:7.1.根据数据生成列表7.2.数组经常和v-for综合使用7.3.语法是(item, index) in数据7.4.item和index可以结合其他指令一起使用7.5.数组长度的更新会同步到页面上,是响应式的 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" name=\"\" id=\"\" value=\"add\" @click=\"add\" /&gt; &lt;input type=\"button\" name=\"\" id=\"\" value=\"remove\" @click=\"remove\" /&gt; &lt;ul&gt; &lt;li v-for=\"(item,index) in arr\"&gt; &#123;&#123; index+1 &#125;&#125;城市:&#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li v-for=\"(item, index) in obj\" :title=\"item.name\"&gt;&#123;&#123;item.age&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var app = new Vue(&#123; el: '#app', data: &#123; arr: [\"北京\", \"上海\", \"广州\", \"深圳\"], obj: [&#123; name: \"rui\", age: 18 &#125;, &#123; name: \"min\", age: 17 &#125;], &#125;, methods: &#123; add: function() &#123; this.obj.push(&#123; name: \"bin\", age: 19 &#125;) &#125;, remove: function() &#123; this.obj.shift(); &#125; &#125; &#125;)&lt;/script&gt; 8.v-on补充8.1.事件绑定的方法写成函数调用的形式,可以传入自定义参数8.2.定义方法时需要定义形参来接收传入的实参8.3.事件的后面跟上.修饰符可以对事件进行限制8.4..enter可以限制触发的按键回车8.5.事件修饰符有多种 12345678910111213141516171819202122&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" name=\"\" id=\"\" value=\"测试一下\" @click=\"cs('测试两下',14)\" /&gt; &lt;input type=\"text\" name=\"\" id=\"\" value=\"\" @keyup.enter=\"sjdj\"/&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var app = new Vue(&#123; el: '#app', methods: &#123; cs: function(a1, a2) &#123; console.log(\"测试一下\"); console.log(a1); console.log(a2); &#125;, sjdj: function() &#123; alert('!!') &#125; &#125; &#125;)&lt;/script&gt; 10.v-model:10.1.便捷的设置和获取表单元素的值10.2.绑定的数据会和表单元素值相关联10.3.绑定的值和修改的数据是双向绑定的,无论修改谁,另一个都会同步更新 123456789101112131415161718192021222324&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" name=\"\" id=\"\" value=\"setM\" @click=\"setM\"/&gt; &lt;input type=\"text\" v-model=\"message\" @keyup.enter=\"getM\"&gt; &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125;, methods: &#123; getM: function()&#123; alert(this.message) &#125;, setM: function()&#123; this.message = \"vue hello!\" &#125; &#125; &#125;)&lt;/script&gt; 小demo123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;div id=\"app\"&gt; &lt;header&gt; &lt;input type=\"text\" name=\"\" id=\"\" value=\"\" v-model=\"inputValue\" @keyup.enter=\"add\"/&gt; &lt;/header&gt; &lt;section&gt; &lt;ul class=\"list\"&gt; &lt;li v-for=\"(item, index) in list\"&gt; &lt;span&gt;&#123;&#123; index+1 &#125;&#125;&lt;/span&gt; &lt;label&gt;&#123;&#123; item &#125;&#125;&lt;/label&gt; &lt;button @click=\"remove(index)\" class=\"close\"&gt;关闭&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;footer v-show=\"list.length!=0\"&gt; &lt;p&gt;&#123;&#123; list.length &#125;&#125;条&lt;/p&gt; &lt;p @click=\"clear\"&gt;clear&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; var app = new Vue(&#123; el: \"#app\", data: &#123; inputValue: \"拉克丝当减肥咯\", list: [\"你好\", \"不好\"] &#125;, methods: &#123; clear: function()&#123; this.list = []; &#125;, add: function()&#123; this.list.unshift(this.inputValue) this.inputValue = \"\" &#125;, remove: function(index)&#123; // console.log(index) this.list.splice(index, 1) &#125; &#125; &#125;)&lt;/script&gt; 网络应用 axios 1.axios必须先导入才可以使用2.使用get或post方法即可发送相对应的请求3.then方法中的回调函数会在请求成功或失败时触发4.通过回调函数的形参可以获取响应内容，或错误信息 格式： 12axios.get(地址?key=value&amp;key2=value).then(function(success)&#123;&#125;,function(err)&#123;&#125;)axios.post(地址,&#123;key=value&amp;key2=value&#125;).then(function(success)&#123;&#125;,function(err)&#123;&#125;) axios + vue1.axios回调函数中的this已经改变，无法访问到data中的数据2.把this保存起来，回调函数中直接使用保存的this即可3.和本地应用最大的区别就是改变了数据来源 12345678910111213141516171819202122232425&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" name=\"\" id=\"\" value=\"获取内容\" @click=\"getJoke\"/&gt; &lt;p&gt;&#123;&#123; joke &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; var app = new Vue(&#123; el: \"#app\", data: &#123; joke: \"p容器\" &#125;, methods: &#123; getJoke: function()&#123; var that = this; axios.get(\"https://autumnfish.cn/api/joke\").then(function(res)&#123; console.log(res) that.joke = res.data &#125;,function(err)&#123; console.log(err) &#125;) &#125; &#125; &#125;)&lt;/script&gt;","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"1.初识PHp","date":"2020-06-01T13:15:16.217Z","path":"2020/06/01/1.初识PHp/","text":"PHP入门所学的散点知识点 memory_get_usage()获取当前php消耗的内存 0 开始的数字为八进制数字 0x 开始的数字为十六进制的数字 unset()释放变量 常量 define() 语法：bool define(string $constant_name,mixed $value[,$case_sensitive = ture])3个参数的含义：第一个参数“constant_name”为必选参数，常量名称,即标志符，常量的命名规则与变量的一致，但是要注意哦，它可不带美元符号哦。第二个参数“value”为必选参数，它是常量的值。第三个参数“case_sensitive”为可选参数，指定是否大小写敏感，设定为true表示不敏感，一般不指定第三个参数的情况下，默认第三个参数的值为false。例：define(“PI”,3.14);define($p,3.14); php 的系统常量 __FILE __ :php程序文件名。它可以帮助我们获取当前文件在服务器的物理位置。__LINE __:PHP程序文件行数。它可以告诉我们，当前代码在第几行。PHP_VERSION:当前解析器的版本号。它可以告诉我们当前PHP解析器的版本号，我们可以提前知道我们的PHP代码是否可被该PHP解析器解析。PHP_OS：执行当前PHP版本的操作系统名称。它可以告诉我们服务器所用的操作系统名称，我们可以根据该操作系统优化我们的代码。 常量的取值 constant()等同于javascript的console.log()defined(常量名)判断常量是否已经定义","tags":[]}]